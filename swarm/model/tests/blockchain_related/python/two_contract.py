from distutils.command.clean import clean
from tree_graph.client.jsonrpc_client import *

import eth_utils
import logging

DEFAULT_TX_GAS_PRICE = 80 * (10 ** 9)
DEFAULT_TX_GAS = 2100000

# contract
RECORDER_ADDR = "0x82d9a0cdece61bdc0d010b0f987000926c13611d"
HANDLER_ADDR = "0x8f2f59cac5b2f40fc381fd4fc34084655fe7e2f0"
# account
PRIVATEKEY = "0xb205017cc1b95e12aa37784b3e66eaf099ba6cf0e80cf10f8fc87b44abba53a7"
ADDR = "0x19aeb665dfa6a8445a46cd9a5c666ac6c0d03c54"

if __name__ == '__main__':
    # logging.basicConfig(level=logging.DEBUG)

    # Create an account with Conflux Portal
    client = JsonRpcClient("localhost", "12537")  
    nextNonce = client.get_nonce(ADDR)
    epoch_number = client.epoch_number()
    # 
    # The data used when calling the contract is generated by ABI encoding based on the function information described by the ABI. 
    # The first 4 bytes are the function selector (the first 4 bytes of the Keccak (SHA-3) hash of the function signature), and the fifth byte starts with the ABI-encoded parameter.

    # =================================================================#
    # test taskHandler func                                            #                                                                                                                        
    # function prototype: taskHandler(string memory taskDesc, uint256) #
    # e.g. taskHandler("mnist", 3)                                     #
    # =================================================================#
    ek = eth_utils.keccak(b"taskHandler(string,uint256)")
    data_prefix = ek[0:4].hex()
    print(f"[+] data prefix = {data_prefix}")
    data_body = "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000056d6e697374000000000000000000000000000000000000000000000000000000"
    data_hex = data_prefix + data_body
    print(f"[+] data hex = {data_hex}")
    print(f"[+] data's len = {len(data_hex)}")
    # b_val = bytes.fromhex(data_hex)
    # tx hash = "0xe4d79c6eb85e5de17b78429138f56212687558ddb26c08f604a8711155617148"


    # =================================================================#
    # test getGift func                                                #                                                                                                                        
    # function prototype: getGift()                                    #
    # e.g. getGift()                                                   #
    # =================================================================#
    # ek = eth_utils.keccak(b"getGift()")
    # data_prefix = ek[0:4].hex()
    # # print(f"[+] data prefix = {data_prefix}")
    # data_body = ""
    # data_hex = data_prefix + data_body
    # # print(f"[+] data hex = {data_hex}")
    # # print(f"[+] data's len = {len(data_hex)}")
    # b_val = bytes.fromhex(data_hex)
    # tx hash = "0xa7a7e50657c38b9ef4f691ed368b87cb0d4fc49a5770f7fdd1f7c53c87894cd7"
    

    # =================================================================#
    # test recordPara func in a single thread                          #                                                                                                                        
    # function prototype: recordPara(int para, uint epoch)             #
    # e.g. recordPara(1, 1)                                            #
    # =================================================================#
    # ek = eth_utils.keccak(b"recordPara(int256,uint256)")
    # data_prefix = ek[0:4].hex()
    # # print(f"[+] data prefix = {data_prefix}")
    # data_body = "00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001"
    # data_hex = data_prefix + data_body
    # # print(f"[+] data hex = {data_hex}")
    # # print(f"[+] data's len = {len(data_hex)}")
    # b_val = bytes.fromhex(data_hex)


    # =================================================================#
    # test recordPara func in a multi thread                           #                                                                                                                        
    # function prototype: recordPara(int para, uint epoch)             #
    # e.g. recordPara(1, 1)                                            #
    # =================================================================#
    
    # send tx
    # tx = client.new_tx(sender='0x19aeb665dfa6a8445a46cd9a5c666ac6c0d03c54',
    #                 #    receiver=HANDLER_ADDR, 
    #                    receiver=RECORDER_ADDR, 
    #                    nonce=nextNonce,
    #                    gas_price=DEFAULT_TX_GAS_PRICE,
    #                    gas=DEFAULT_TX_GAS,
    #                    value=0, 
    #                    data=b_val, 
    #                    sign=True, 
    #                    priv_key=PRIVATEKEY, 
    #                    epoch_height=epoch_number, 
    #                    chain_id=0)
    # tx_hash = client.send_tx(tx)
    # print("[+] the send transaction hash is ", tx_hash)  
    
    # 
    # tx_hash = ""
    # tx_info = client.get_tx(tx_hash)
    # print(f"[+] the tx info of {tx_hash} is ", tx_info)
    
    # tx_receipt = client.get_transaction_receipt(tx_hash)
    # print(f"[+] the tx receip of {tx_hash} is ", tx_receipt)     # the contract is deployed after sending a transaction with data as bytecode. 
                                                            # The contractCreated field of the transaction receipt is the contract address after deployment.

    

