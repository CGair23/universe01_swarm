from re import A
from tree_graph.client.jsonrpc_client import *
from utils import priv_to_addr
import logging

DEFAULT_TX_GAS_PRICE = 80 * (10 ** 9)
DEFAULT_TX_GAS = 2100000
DEFAULT_BALANCE = 10000 * 10 ** 18

if __name__ == '__main__':
    # logging.basicConfig(level=logging.DEBUG)
    Bob_addr = "0x19aeb665dfa6a8445a46cd9a5c666ac6c0d03c54"
    Bob_prik = "0xb205017cc1b95e12aa37784b3e66eaf099ba6cf0e80cf10f8fc87b44abba53a7"

    # 
    genesis_pri_key = eth_utils.decode_hex("0x46b9e861b63d3509c88b7817275a30d22d62c8cd8fa6486ddee35ef0d8e0495f")
    genesis_addr = eth_utils.encode_hex(priv_to_addr(genesis_pri_key))



    # client = JsonRpcClient("58.246.44.146", "12537")
    # print(f"[+] the epoch number is {client.epoch_number()}")
    client = JsonRpcClient("localhost", "12537")

    # Create an account with Conflux Portal
    # Alice_addr, Alice_prik = client.gen_account()
    # print(f"[+] Alice's account: {Alice_addr}, Alice's private key: {Alice_prik}")

    # this is Alice
    Alice_addr = "0x1f9422c17a85f15473d5e25834d17d48c2356c7c"
    Alice_prik = "0x5bba79b1fbba518c7283750cf6a1175f3180fab586c1b1787539885f3132ef4f"

    # Export and copy your private key to somewhere, we'll use it later.
    # print(f"RANDOM ACCOUNT={client.gen_account()}")  # maybe there will raise the following error "import _tkinter # If this fails your Python may not be configured for Tk ModuleNotFoundError: No module named '_tkinter'"
                                                     # somehow I run `brew install python-tk` to fix it

    # 
    nextNonce = client.get_nonce(Alice_addr)
    print(f"[+] the next nonce of account {Bob_addr} is ", hex(nextNonce))

    balance = client.get_balance(genesis_addr)
    print(f"[+] the balance of genesis addr {genesis_addr} is ", balance)

    #
    balance = client.get_balance(Bob_addr)
    print(f"[+] the balance of Bob:{Bob_addr} is ", balance)
    balance = client.get_balance(Alice_addr)
    print(f"[+] the balance of Alice:{Alice_addr} is ", balance)

    
    # top up
    # genesis_nextNonce = client.get_nonce(genesis_addr)
    # print(f"[+] the next nonce genesis addr {genesis_addr} is ", genesis_nextNonce)
    epoch_number = client.epoch_number()
    # tx = client.new_tx(
    #     sender=genesis_addr,
    #     priv_key=genesis_pri_key,
    #     receiver=Alice_addr,
    #     gas_price=DEFAULT_TX_GAS_PRICE,
    #     gas=DEFAULT_TX_GAS,
    #     value=DEFAULT_BALANCE,
    #     epoch_height=epoch_number, 
    #     nonce=genesis_nextNonce)
    # tx_hash = client.send_tx(tx)

    # TODO: FIXME
    # client.top_up(Bob_addr)
    # client.top_up(Alice_addr)

    # violent charging
    # balance = client.get_balance(addr)
    # print(f"[+] the balance of {addr} after charging is ", balance)

    #
    # epoch_number = client.epoch_number()
    # print("[+] epoch number is ", epoch_number)

    # The contract deployment is creating a contract instance on the blockchain 
    # by sending a transaction with data as bytecode and to left empty.
    # 
    # The data used when calling the contract is generated by ABI encoding based on the function information described by the ABI. 
    # The first 4 bytes are the function selector (the first 4 bytes of the Keccak (SHA-3) hash of the function signature), and the fifth byte starts with the ABI-encoded parameter.
    data = "01"
    b_val = bytes.fromhex(data)
    tx = client.new_tx(sender=Alice_addr,
                       receiver='0x0000000000000000000000000000000000000002', 
                       nonce=nextNonce,
                       gas_price=DEFAULT_TX_GAS_PRICE,
                       gas=DEFAULT_TX_GAS,
                       value=0, 
                       data=b_val, 
                       sign=True, 
                       priv_key=Alice_prik, 
                       epoch_height=epoch_number, 
                       chain_id=0)
    # tx_hash = client.send_tx(tx)
    # print("[+] the send transaction hash is ", tx_hash)  
    # 
    # tx_hash = ""
    # tx_info = client.get_tx(tx_hash)
    # print(f"[+] the tx info of {tx_hash} is ", tx_info)
    
    # tx_receipt = client.get_transaction_receipt(tx_hash)
    # print(f"[+] the tx receip of {tx_hash} is ", tx_receipt)     # the contract is deployed after sending a transaction with data as bytecode. 
                                                            # The contractCreated field of the transaction receipt is the contract address after deployment.

    import hashlib
    m = hashlib.sha256()
    m.update(b_val)
    dh = "0x" + (m.digest()).hex()
    print(f"[+] digest in hex: {dh}")
    res = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
